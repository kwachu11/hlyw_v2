{% extends "base.html" %}
{% block content %}
<head>
    <link rel="stylesheet" href="{{ url_for('static', filename='gameStyles/tetris.css') }}">
</head>

<center>
    <div class="mainLayout">
        <h1 id="mainHeader">Tetris by Hlyw</h1>
        <div class="mainLayout_container">
            <div class="game-area">
                <canvas id="gameCanvasTetris" width="300" height="600"></canvas>
            </div>
            <div class="mainLayout_controls">
                <div class="mainLayout_controls_start mb-2">
                    <button id="start-button" class="btn btn-primary start-button">Rozpocznij grę</button>
                </div>
                <div class="mainLayout_controls_buttons mt-3">
                    <button id="rotate" class="btn btn-secondary rotate-button">Obróć<br>(spacja)</button>
                    <div class="mainLayout_controls_buttonGroup mb-2 mt-3">
                        <button id="left" class="btn btn-secondary">←</button>
                        <button id="right" class="btn btn-secondary">→</button>
                        <button id="down" class="btn btn-secondary">↓</button>
                    </div>
                    <div id="score" class="mt-2">Wynik: 0</div>
                </div>
            </div>
        </div>
    </div>
</center>




    <script>
const canvas = document.getElementById("gameCanvasTetris");
canvas.width = 300;
canvas.height = 600;
const ctx = canvas.getContext("2d");

const box = 30; // Rozmiar pojedynczego kwadratu
const rows = canvas.height / box; // Liczba wierszy
const columns = canvas.width / box; // Liczba kolumn
let score = 0;
let gameOver = false;
let showWelcomeMessage = true;

    function drawText(text, x, y) {
    ctx.font = "50px Pricedown"; // Ustaw czcionkę
    ctx.fillStyle = "white"; // Ustaw kolor tekstu
    ctx.fillText(text, x, y); // Narysuj tekst
}

const colors = [
    null,
    'cyan', // I
    'blue', // J
    'orange', // L
    'yellow', // O
    'green', // S
    'purple', // T
    'red' // Z
];

// Zdefiniuj kształty Tetrisa
const pieces = [
    [],
    [[1, 1, 1, 1]], // I
    [[0, 0, 2], [2, 2, 2]], // J
    [[3, 3, 3], [0, 0, 3]], // L
    [[4, 4], [4, 4]], // O
    [[0, 5, 5], [5, 5, 0]], // S
    [[6, 6, 6], [0, 6, 0]], // T
    [[0, 7, 7], [7, 7, 0]]  // Z
];

let board = Array.from({ length: rows }, () => Array(columns).fill(0));
let currentPiece;
let currentPosition;

// Funkcja do rysowania planszy
function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < columns; c++) {
            if (board[r][c] !== 0) {
                const color = colors[board[r][c]];
               
                // Apply gradient to simulate 3D effect
                const x = c * box;
                const y = r * box;
                const gradient = ctx.createLinearGradient(x, y, x + box, y + box);
                gradient.addColorStop(0, lightenColor(color, 20)); // Lighter shade at the top
                gradient.addColorStop(1, color); // Main color
                
                // Fill with gradient for 3D brick effect
                ctx.fillStyle = gradient;
                drawRoundedRect(ctx, x, y, box, box, 5);

                // Add a darker border around each tile
                ctx.strokeStyle = darkenColor(color, 30);
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, box, box);
            }
        }
    }
}

// Funkcja do rysowania aktualnego kawałka
function drawPiece() {
    currentPiece.shape.forEach((row, rowIndex) => {
        row.forEach((cellValue, colIndex) => {
            if (cellValue !== 0) {
                // Calculate the position for each block
                const xPosition = (currentPosition.x + colIndex) * box;
                const yPosition = (currentPosition.y + rowIndex) * box;

                // Create a brick-like color gradient
                const gradient = ctx.createLinearGradient(xPosition, yPosition, xPosition + box, yPosition + box);
                gradient.addColorStop(0, lightenColor(colors[cellValue], 20)); // Lighter shade for the top
                gradient.addColorStop(1, colors[cellValue]); // Main color

                // Fill with gradient for 3D brick effect
                ctx.fillStyle = gradient;
                drawRoundedRect(ctx, xPosition, yPosition, box, box, 5); // Rounded corners

                // Add a darker border around the block
                ctx.strokeStyle = darkenColor(colors[cellValue], 30); // Darker shade for border
                ctx.lineWidth = 2;
                ctx.strokeRect(xPosition, yPosition, box, box);
            }
        });
    });
}

// Helper function to draw rounded rectangles
function drawRoundedRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.fill();
}

// Helper to lighten color for gradient effect
function lightenColor(color, percent) {
    const num = parseInt(color.replace("#", ""), 16);
    const amt = Math.round(2.55 * percent);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 0x00FF) + amt;
    const B = (num & 0x0000FF) + amt;
    return `#${((1 << 24) + (Math.min(R, 255) << 16) + (Math.min(G, 255) << 8) + Math.min(B, 255)).toString(16).slice(1)}`;
}

// Helper to darken color for border effect
function darkenColor(color, percent) {
    const num = parseInt(color.replace("#", ""), 16);
    const amt = Math.round(2.55 * percent);
    const R = (num >> 16) - amt;
    const G = (num >> 8 & 0x00FF) - amt;
    const B = (num & 0x0000FF) - amt;
    return `#${((1 << 24) + (Math.max(R, 0) << 16) + (Math.max(G, 0) << 8) + Math.max(B, 0)).toString(16).slice(1)}`;
}

// Sprawdź, czy kawałek może być umieszczony w danej pozycji
function canMove(offsetX, offsetY) {
    return currentPiece.shape.every((row, r) => {
        return row.every((value, c) => {
            if (value === 0) return true;
            const newX = currentPosition.x + c + offsetX;
            const newY = currentPosition.y + r + offsetY;
            return newY >= 0 && newY < rows && newX >= 0 && newX < columns && !board[newY][newX];
        });
    });
}

// Dodaj kawałek do planszy
function addPieceToBoard() {
    currentPiece.shape.forEach((row, r) => {
        row.forEach((value, c) => {
            if (value !== 0) {
                board[currentPosition.y + r][currentPosition.x + c] = value;
            }
        });
    });
}

// Usuń pełne linie
function removeFullLines() {
    for (let r = rows - 1; r >= 0; r--) {
        if (board[r].every(value => value !== 0)) {
            board.splice(r, 1);
            board.unshift(Array(columns).fill(0));
            score += 10;
            document.getElementById("score").innerText = "Score: " + score;
            r++; // Sprawdź ponownie tę samą linię
        }
    }
}

// Rotuj kawałek
function rotatePiece() {
    const rotatedShape = currentPiece.shape[0].map((val, index) =>
        currentPiece.shape.map(row => row[index]).reverse()
    );
    if (canMove(0, 0)) {
        currentPiece.shape = rotatedShape;
    }
}

// Zainicjuj nowy kawałek
function initPiece() {
    const randomIndex = Math.floor(Math.random() * (pieces.length - 1)) + 1;
    currentPiece = { shape: pieces[randomIndex] };
    currentPosition = { x: Math.floor(columns / 2) - 1, y: 0 };
    if (!canMove(0, 0)) {
        gameOver = true;
    }
}

// Start gry
function startGame() {
    showWelcomeMessage = false;
    gameOver = false;
    score = 0;
    board = Array.from({ length: rows }, () => Array(columns).fill(0));
    initPiece();
    gameLoop();
}

napis_hlyw(false);

    function napis_hlyw(aktywnosc) {
    if(aktywnosc == false)
    {
        const font = new FontFace('Pricedown', 'url(static/css/fonts/pricedown.otf)');
        document.fonts.add(font);

        font.load().then(() => {
            document.fonts.add(font);
            drawText("Tetris", canvas.width / 2 - 120, canvas.height / 2-20); // Wyśrodkowanie tekstu
            drawText("by", canvas.width / 2, canvas.height / 2+22);
            drawText("Hlyw", canvas.width / 2, canvas.height / 2+65);
        }).catch(error => {
            console.error('Błąd podczas ładowania czcionki:', error);
        });
    }
    }

// Główna pętla gry
function gameLoop() {
    if (gameOver) {
        //alert("Koniec gry! Twój wynik: " + score);
        endGame(score);
        return;
    }

    if (canMove(0, 1)) {
        currentPosition.y++;
    } else {
        addPieceToBoard();
        removeFullLines();
        initPiece();
    }

    drawBoard();
    drawPiece();

    setTimeout(gameLoop, 200);
}

// Obsługuje ruchy z przycisków
document.getElementById("left").addEventListener("click", () => {
    if (canMove(-1, 0)) {
        currentPosition.x--;
    }
});

document.getElementById("right").addEventListener("click", () => {
    if (canMove(1, 0)) {
        currentPosition.x++;
    }
});

document.getElementById("down").addEventListener("click", () => {
    if (canMove(0, 1)) {
        currentPosition.y++;
    }
});

document.getElementById("rotate").addEventListener("click", rotatePiece);

//przyciski na klawiaturze
document.addEventListener("keydown", function(event) {
    if (event.key === "ArrowLeft") {
    event.preventDefault();
        document.getElementById("left").click(); // Symuluj kliknięcie lewego przycisku
    } else if (event.key === "ArrowRight") {
    event.preventDefault();
        document.getElementById("right").click(); // Symuluj kliknięcie prawego przycisku
    } else if (event.key === "ArrowDown") {
    event.preventDefault();
        document.getElementById("down").click(); // Symuluj kliknięcie przycisku w dół
    } else if (event.key === " ") {
    event.preventDefault();
        document.getElementById("rotate").click(); // Symuluj kliknięcie przycisku Spacja
    } else if (event.key === "ArrowUp"){
    event.preventDefault();
    }
});

    // Obsługa kliknięcia przycisku
    document.getElementById('start-button').addEventListener('click', startGame);

        function endGame(score) {
        fetch('/tetris/save_score', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ score: score })
        })
        .then(response => response.json())
        .then(data => {
            // Przekierowanie do odpowiedniej strony po zapisaniu wyniku
            window.location.href = data.redirect_url;
        })
        .catch(error => console.error('Błąd:', error));
    }
</script>

{% endblock %}